{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/TIL/Spring Boot/코드로-배우는-스프링부트/part1/Maria 데이터베이스와 Spinrg Data SPA","result":{"data":{"markdownRemark":{"id":"b3db26b4-f46c-5d65-85ee-afff739154b9","html":"<h1 id=\"chapter-2-maria-데이터베이스와-spring-data-jpa\" style=\"position:relative;\"><a href=\"#chapter-2-maria-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%99%80-spring-data-jpa\" aria-label=\"chapter 2 maria 데이터베이스와 spring data jpa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 2 Maria 데이터베이스와 Spring Data JPA</h1>\n<h2 id=\"maira-db\" style=\"position:relative;\"><a href=\"#maira-db\" aria-label=\"maira db permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Maira DB?</h2>\n<p>MySQL과 거의 유사하지만 완전한 오픈소스\n<a href=\"./../../TIL/Database/MariaDB%20docker%EC%97%90%20%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0.md\">MariaDB docker에 설치하기</a></p>\n<h2 id=\"db를-위한-스프링-부트-설정\" style=\"position:relative;\"><a href=\"#db%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-%EC%84%A4%EC%A0%95\" aria-label=\"db를 위한 스프링 부트 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DB를 위한 스프링 부트 설정</h2>\n<p>스프링 부트에서는 <code class=\"language-text\">Auto Configure</code>이라는 자동 설정 기능이 있다.</p>\n<ul>\n<li>특정한 라이브러리가 있다면 이에 관련된 설정을 자동으로 추가</li>\n<li>Spring Data JPA가 의존성으로 추가되었기 때문에, 이에 대한 설정이 자동으로 추가</li>\n</ul>\n<p>구체적인 값은 직접 지정해줘야 한다.<br>\n<code class=\"language-text\">build.gradle</code>에 mariadb 관련 구문을 추가하자</p>\n<ul>\n<li><a href=\"https://mvnrepository.com/artifact/org.mariadb.jdbc/mariadb-java-client/2.7.1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">maven 저장소</a>에서 최신 버전을 알아볼 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">compile group: &#39;org.mariadb.jdbc&#39;, name: &#39;mariadb-java-client&#39;, version: &#39;2.7.1&#39;</code></pre></div>\n<p>추가적인 데이터베이스 설정을 추가합니다.</p>\n<ul>\n<li><code class=\"language-text\">application.properties</code>을 이용하거나 별도의 클래스 파일을 작성해 사용가능</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># 데이터베이스 설정을 위한 부분, Driver, Databse 주소, user, password 등록\nspring.datasource.driver-class-name=org.mariadb.jdbc.Driver\nspring.datasource.url=jdbc:mariadb://localhost:3306/test_db\nspring.datasource.username=username               #username\nspring.datasource.password=password               #password</code></pre></div>\n<h2 id=\"spring-data-jpa-소개\" style=\"position:relative;\"><a href=\"#spring-data-jpa-%EC%86%8C%EA%B0%9C\" aria-label=\"spring data jpa 소개 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring Data JPA 소개</h2>\n<p>JPA는 JAVA언어를 통해서 데이터베이스와 같은 영속 계층을 처리하고자 하는 스펙</p>\n<h3 id=\"orm과-jpa\" style=\"position:relative;\"><a href=\"#orm%EA%B3%BC-jpa\" aria-label=\"orm과 jpa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ORM과 JPA</h3>\n<p>ORM(Object Relational Mapping)은 객체지향과 관련</p>\n<blockquote>\n<p>객체지향 패러다임을 관계형 패러다임으로 매핑해주는 개념</p>\n</blockquote>\n<p>객체지향의 구조가 관계형 데이터베이스와 유사하다는 점에서 시장<br>\nRDB에서는 테이블을 설계할 때 칼럼을 정의하고 칼럼에 맞는 데이터 타입을 지정해 데이터를 보관하는 틀을 만든다는 의미에서 클래스와 유사하다.  </p>\n<p>객체지향과 관계형 데이터베이스는 유사한 특징을 가지고 있는데, 이런 특정에 기초해서</p>\n<blockquote>\n<p>객체지향을 자동으로 관계형 데이터베이스에 맞게 처리 해주는 기법이 ORM이다.</p>\n</blockquote>\n<p>JPA는 Java Persistence API의 약어로 ORM을 Java 언어에 맞게 사용하는 스펙이다.\nORM이 JPA의 더 상위 개념이며, JPA를 구현한 프레임워크 중 Spring에서는 Hibernate를 기본적으로 사용한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/77606318/105649385-63d68880-5ef3-11eb-8078-e45b7b7a2996.png\" alt=\"image\">\n<img src=\"https://user-images.githubusercontent.com/77606318/105649421-8f597300-5ef3-11eb-8e75-0254a8ebdc31.png\" alt=\"image\"></p>\n<h2 id=\"entity-class와-jparepository\" style=\"position:relative;\"><a href=\"#entity-class%EC%99%80-jparepository\" aria-label=\"entity class와 jparepository permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Entity Class와 JpaRepository</h2>\n<p>Spring Data JPA가 개발에 필요한 것은 단지 두 종류의 코드로 구현 가능</p>\n<ul>\n<li>JPA를 통해서 관리하게 되는 객체(Entity Object)를 위한 엔티티 클래스</li>\n<li>엔티티 객체들을 처리하는 기능을 가진 Repository</li>\n</ul>\n<p>이 중 Repository는 Spring Data JPA에서 제공하는 인터페이스로 설계</p>\n<h2 id=\"spring-boot-jpa-설정\" style=\"position:relative;\"><a href=\"#spring-boot-jpa-%EC%84%A4%EC%A0%95\" aria-label=\"spring boot jpa 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring Boot JPA 설정</h2>\n<p>JPA 이용 시 생기는 여러가지 상황을 설정으로 적용</p>\n<p>spring.jpa.hibernate.ddl-auto</p>\n<ul>\n<li>프로젝트 실행 시 DDL을 생성할 것인지 정하는 설정</li>\n<li>설정값은 create, update, create-drop, validate등등</li>\n</ul>\n<p>spring.jpa.properties.hibernate.format_sql=true</p>\n<ul>\n<li>실제 jpa 구현체인 hiberante가 동작하며 발생하는 sql을 포맷팅 하여 출력</li>\n<li>true, false</li>\n</ul>\n<p>spring.jpa.show-sql</p>\n<ul>\n<li>jpa 처리 시에 발생하는 sql을 보여줄 것인지 결정</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">spring.jpa.hibernate.ddl-auto=update\nspring.jpa.properties.hibernate.format_sql=true\nspring.jpa.show-sql=true</code></pre></div>\n<h2 id=\"jparepository-인터페이스-구조\" style=\"position:relative;\"><a href=\"#jparepository-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B5%AC%EC%A1%B0\" aria-label=\"jparepository 인터페이스 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JpaRepository 인터페이스 구조</h2>\n<p>여러 종류의 인터페이스 기능을 통해 JPA 관련 작업을 별도의 코드 없이 처리할 수 있게 지원</p>\n<p><img src=\"https://user-images.githubusercontent.com/77606318/105662393-f2a6cd80-5f12-11eb-937d-5580a0e1fdf2.png\" alt=\"image\"></p>\n<p>일반적인 기능만을 사용할 때는 <code class=\"language-text\">CrudRepository</code> 를 사용<br>\n모든 JPA관련 기능을 사용하고 싶을 때는 <code class=\"language-text\">JpaRepository</code> 사용</p>\n<p>실제로 Repository를 사용하기 위해서는 위 인터페이스를 상속하는 것으로 모든게 해결</p>\n<ul>\n<li>interface만 등록하면 (<code class=\"language-text\">MemoRepostiroy</code>를 등록하면) 스프링에서 자동적으로 빈(bean)으로 등록</li>\n<li>내부적으로 인터페이스 타입에 맞는 객체를 생성해 빈으로 등록</li>\n</ul>\n<p>기본적인 인터페이스</p>\n<ul>\n<li>\n<p>insert</p>\n<ul>\n<li><code class=\"language-text\">save(Entity Object)</code></li>\n</ul>\n</li>\n<li>\n<p>select</p>\n<ul>\n<li><code class=\"language-text\">findById(Key Type), getOne(Key Type)</code></li>\n</ul>\n</li>\n<li>\n<p>update</p>\n<ul>\n<li><code class=\"language-text\">save(Entity Object)</code></li>\n</ul>\n</li>\n<li>\n<p>delete</p>\n<ul>\n<li><code class=\"language-text\">deleteById(Key type), delete(Entity Object)</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"insert-update-모두-save\" style=\"position:relative;\"><a href=\"#insert-update-%EB%AA%A8%EB%91%90-save\" aria-label=\"insert update 모두 save permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>insert, update 모두 save()?</h3>\n<p>JPA 구현체가 메모리상에서 객체를 비교하고 (select 구문 1번), 없다면 insert 존재한다면 update를 동작시키는 방식으로 동작하기 때문</p>\n<h3 id=\"findbyid-getone-동작방식\" style=\"position:relative;\"><a href=\"#findbyid-getone-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D\" aria-label=\"findbyid getone 동작방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>findById(), getOne() 동작방식</h3>\n<p>데이터베이스를 먼저 이용하는지, 나중에 필요한 순간까지 미루는지에 대한 차이  </p>\n<p>findById()</p>\n<ul>\n<li>Java.util 패키지의 <code class=\"language-text\">Optional</code> 타입으로 반환되기 때문에 한번 더 결과가 존재하는지 체크하는 형태로 작성</li>\n<li>실행 순간에 이미 SQL처리는 완료되었고, 결과에 대해서는 이후에 처리</li>\n</ul>\n<p>getOne()</p>\n<ul>\n<li><code class=\"language-text\">@Transactional</code> 어노테이션이 추가로 필요</li>\n<li>반환 값은 해당 객체지만, 실제 객체가 필요한 순간까지 SQL을 실행하지 않고 보류</li>\n</ul>\n<h2 id=\"chapter-25-페이징--정렬-처리\" style=\"position:relative;\"><a href=\"#chapter-25-%ED%8E%98%EC%9D%B4%EC%A7%95--%EC%A0%95%EB%A0%AC-%EC%B2%98%EB%A6%AC\" aria-label=\"chapter 25 페이징  정렬 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>chapter 2.5 페이징 / 정렬 처리</h2>\n<p>페이징 처리와 정렬을 위해 오라클은 inline view를, mysql은 limit을 알아야 한다.<br>\nJPA는 내부적으로 이런 처리를 ‘Dialect’라는 존재를 이용해서 처리를 findAll()이라는 메서드를 사용  </p>\n<ul>\n<li>JpaRepository 인터페이스의 상위인 PagingAndSorRepository의 메서드로 파라미터로 전달되는 Pageableㅣ라는 타입의 객체에 의해서 실행되는 쿼리를 결정</li>\n<li>Return type이 <code class=\"language-text\">Page&lt;T&gt;</code>라면 꼭 Pageable 파라미터로 이용해야 한다.\nPageable 인터페이스  </li>\n</ul>\n<p><code class=\"language-text\">org.springframework.data.domain.PageRequest</code> 라는 클래스를 사용</p>\n<ul>\n<li><code class=\"language-text\">protected</code>로 선언되어 <code class=\"language-text\">new</code>를 선언할 수 없다.</li>\n<li>객체를 생성하기 위해 static한 <code class=\"language-text\">of()</code>를 이용해 처리</li>\n<li><code class=\"language-text\">PageRequest</code>생성자에서 <code class=\"language-text\">page, size, Sort</code>라는 정보를 이용해 객체 생성</li>\n</ul>\n<p>static 메서드인 <code class=\"language-text\">of()</code>의 경우 형태가 여러개 존재, 이는 페이지 처리에 필요한 정렬 조건을 같이 지정하기 위해서</p>\n<ul>\n<li><code class=\"language-text\">of(int page, int size)</code> : 0부터 시작하는 페이저 번호과 개수, 정렬이 지정되지 않음</li>\n<li><code class=\"language-text\">of(int page, int size, Sort.Direction direction, String ...props)</code> : 0부터 시작하는 페이지 번호와 개수, 정렬의 방향과 정렬 기준 필드</li>\n<li><code class=\"language-text\">of(int page, int size, Sort sort)</code>: 페이지 번호와 개수, 정렬 관련 정보</li>\n</ul>\n<h3 id=\"페이징-처리\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%B2%98%EB%A6%AC\" aria-label=\"페이징 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 처리</h3>\n<p>항상 0부터 시작한다.<br>\nfindAll()의 반환값은 Page타입이라는점  </p>\n<ul>\n<li>해당 목록만 가져오는데 그치지 않고, 실제 페이지 처리에 필요한 전체 데이터의 개수를 가져오는 쿼리 역시 같이 처리하기 때문  </li>\n</ul>\n<p>Page&#x3C;엔티티 타입> 의 다양한 메서드 사용가능</p>\n<ul>\n<li>getTotalPages() : 총 페이지 수</li>\n<li>getTotalElementes() : 전체 개수</li>\n<li>getNumber() : 현재 페이지 번호 (0부터 시작)</li>\n<li>getSize() : 페이지당 데이터 개수</li>\n<li>hasNext() : 다음 페이지 존재 여부</li>\n<li>isFirst() : 시작 페이지(0) 여부</li>\n<li>getcontent() : List&#x3C;엔티티>으로 처리 가능</li>\n<li>get() : Stream&#x3C;엔티티>으로 처리 가능</li>\n</ul>\n<h3 id=\"정렬-처리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A0%AC-%EC%B2%98%EB%A6%AC\" aria-label=\"정렬 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정렬 처리</h3>\n<p>PageRequest에는 <code class=\"language-text\">org.springframework.data.domain.Sort</code> 타입을 파라미터로 전달 가능</p>\n<ul>\n<li>한 개 혹은 여러 개의 필드값을 이용해 정렬 방향 등을 지정가능</li>\n<li>여러 개의 Sort 같은 경우 and, or등으로 연결 가능</li>\n</ul>\n<h2 id=\"chapter-26-쿼리-메서드로\" style=\"position:relative;\"><a href=\"#chapter-26-%EC%BF%BC%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C\" aria-label=\"chapter 26 쿼리 메서드로 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>chapter 2.6 쿼리 메서드로</h2>\n<p>마지막 기능은 쿼리 메서드와 <code class=\"language-text\">JPQL(Java Persistence Query Language)</code><br>\n다양한 검색조건이나 특정 범위 객체 검색의 경우<br>\nSpring Data JPA의 경우 이러한 처리를 위해 방법 제공  </p>\n<ul>\n<li>쿼리 메서드 : 메서드의 이름 자체가 쿼리의 구문으로 처리되는 기능</li>\n<li>@Query : SQL과 유사하게 엔티티 클래스의 정보를 이용해서 쿼리를 작성하는 기능</li>\n<li>Querydsl 등의 동적 처리 기능</li>\n</ul>\n<h3 id=\"쿼리-메서드란\" style=\"position:relative;\"><a href=\"#%EC%BF%BC%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%9E%80\" aria-label=\"쿼리 메서드란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쿼리 메서드란</h3>\n<p>메서드의 이름 자체가 질의(query)문이 되는 흥미로운 기능<br>\nfindBy, getBy… 등으로 시작하고 자세한 종류는 <code class=\"language-text\">Spring Data JPA Reference</code>를 통해 알아볼 수 있다.<br>\n필요한 필드 조건이나 <code class=\"language-text\">And, Or</code>등의 키워드를 통해서 질의 조건을 만들어 낸다.  </p>\n<p>다양한 장점들</p>\n<ul>\n<li>select를 하는 작업이라면 List 타입이나 배열을 이용 할 수 있다.</li>\n<li>파라미터에 Pageable 타입을 넣는 경우, 무조건 <code class=\"language-text\">Page&lt;Entity&gt;</code> 타입</li>\n</ul>\n<h3 id=\"query-어노테이션\" style=\"position:relative;\"><a href=\"#query-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98\" aria-label=\"query 어노테이션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@Query 어노테이션</h3>\n<p>간단한 처리만 쿼리 메서드를 이용, @Query를 더 많이 사용<br>\n메서드의 이름과 상관없이 메서드에 추가한 어노테이션을 통해 원하는 처리 가능<br>\nJPQL이라고 부르는 객체지향 쿼리 구문 사용<br>\n다음과 같은 작업 진행  </p>\n<ul>\n<li>필요한 데이터만 선별적으로 추출</li>\n<li>데이터베이스에 맞는 순수한 SQL(Native SQL)을 사용하는 기능</li>\n<li>insert, update, delete 등 DML을 처리하는 기능 (@Modifying과 함께 사용)  </li>\n</ul>\n<p>객체지향 쿼리는 테이블 대신 엔티티 클래스 이용<br>\n테이블의 칼럼 대신에 클래스에 선언된 필드를 이용해 작성  </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">@ <span class=\"token class-name\">Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select m from Memo m order by m.mno desc\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Memo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getListDesc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>파라미터 바인딩</p>\n<ul>\n<li>?1, ?2 와 1부터 시작하는 파라미터의 순서를 이용하는 방식</li>\n<li>:xxx 와 같이 파라미터 이름을 활용하는 방식</li>\n<li>:#{} 와 같이 자바 빈 스타일을 이용</li>\n<li><code class=\"language-text\">@Param</code> 어노테이션을 통해서 파라미터를 적는다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@Modifying</span>\n<span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"update Memo m set m.memoText = :memoText where m.mno = :mno\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">updateMemoText</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Param</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mno\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">Long</span> mno<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@Parama</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"memoText\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> memoText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"update Memo m set m.memoText = :#{#param.memoText} where m.mno = :#{#param.mno}\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">updateMemoText</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Param</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mno\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">Long</span> mno<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@Parama</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"memoText\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> memoText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>페이징 처리를 위해서 Pageable 파라미터를 적용</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Queru</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"select m from Memo m where m.mno > :mno\"</span><span class=\"token punctuation\">,</span> countQuery <span class=\"token operator\">=</span> <span class=\"token string\">\"select count(m) from Memo m where m.mon > :mno\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">Page</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Memo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getListWithQuery</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span> mno<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Pageable</span> <span class=\"token class-name\">Pageable</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>@Query의 장점 중 하나는 쿼리 메서드의 경우 엔티티 타입의 데이터만을 추출하지만 @Query를 사용하면 <code class=\"language-text\">Object[]</code>의 형태로 선별적으로 추출</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@query</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"select m.mno, m.memoText, CURRENT_DATE from Memo m where m.mno > :mno\"</span><span class=\"token punctuation\">,</span> \n        countQuery <span class=\"token operator\">=</span> <span class=\"token string\">\"select count(m) from Memo m where m.mno > :mno\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">Page</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span> <span class=\"token function\">getListWithQueryObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span> mno<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Pageable</span> pageable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>ß</code></pre></div>\n<ul>\n<li>\n<p>Native SQL 처리</p>\n<ul>\n<li>데이터 베이스 고유의 SQL을 그대로 사용 가능ß</li>\n<li>@Query의 nativeQuery속성을 true로 설정하면 기존의 SQL그대로 사용가능</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/posts/TIL/Spring Boot/코드로-배우는-스프링부트/part1/Maria 데이터베이스와 Spinrg Data SPA","tagSlugs":["/tag/코드로-배우는-스프링부트/","/tag/spring/","/tag/spring-boot/","/tag/maria-db/","/tag/spring-data-jpa/"]},"frontmatter":{"date":"2021-01-19T23:46:37.121Z","description":"코드로 배우는 스프링부트 part1/chapter2 Maria 데이터베이스와 Spinrg Data SPA","tags":["코드로-배우는-스프링부트","Spring","Spring Boot","MariaDB","Spring Data JPA"],"title":"Maria 데이터베이스와 Spring Data JPA","socialImage":null}}},"pageContext":{"slug":"/posts/TIL/Spring Boot/코드로-배우는-스프링부트/part1/Maria 데이터베이스와 Spinrg Data SPA"}},"staticQueryHashes":["251939775","401334301","825871152"]}