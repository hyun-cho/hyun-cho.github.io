---
title: Javascript 문법정리_1
date: "2021-01-27T02:30:44.175Z"
template: "post"
draft: false
slug: "Javascript 문법정리_1"
category: "Javascript"
tags:
  - "Javascript"
  - "ECMAscript"
description: "Javscript 문법 정리 1"
---

# Javascript 문법 정리

[모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567)와 [MDN](https://developer.mozilla.org/ko/)를 보고 요약한 내용입니다.

앞으로 사용한 Javascript 문법을 하나씩 정리해보자.  
- 변수
- 표현식과 문
- 데이터 타입
- 연산자
- 제어문
- 타입 변화과 단축 평가

설명은 하나 이상의 언어에 대한 지식이 있다는 가정하에 설명한다.  

<br><br>

# 변수

## 변수란?

하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름  
- 변수명 : 변수의 이름
- 할당 : 변수에 값을 저장
- 참조 : 변수에 저장된 값을 읽어 들이는 것

## 식별자

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름
- 값이 아니라 메모리 주소를 가지고 있다.

## 변수 선언

변수 사용을 위해선 반드시 선언이 필요  
변수 선언을 위해서 var, let, const를 사용한다.  
선언된 공간에 값을 할당하지 않으면, 기본적으로 `undefined`를 암묵적으로 할당한다.  

```js
var score; //undefined
```

## 변수 호이스팅

선언되지 않은 변수를 참조하게 되면 `ReferenceError`가 발생하는데, 아래 구문에서는 에러가 발생하지 않는다.  

```js
console.log(score); //undefined
var score;          //변수 선언
```

그 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 런타임이 아닌 그 이전 단계에서 실행되기 때문  
위와 같은 자바스크립트 고유의 방식을 `변수 호이스팅` 이라고 한다.  
변수 선언 뿐만 아니라 `var`, `let`, `const`, `function*`, `class` 키워드 또한 변수 호이스팅이 일어나게 된다.

## 값의 할당

할당에는 할당 연산자 `=`를 사용  
하나의 구문으로 보이지만 변수 선언 + 할당 2단계로 나누어져 실행된다.    
변수 선언은 호이스팅이 일어나 먼저 실행되고, 할당은 소스코드의 순서대로 실행된다.  

```js
var score = 80; 
```

var 변수는 같은 메모리 공간에 대해서 재할당이 이루어지지 않는다.  
재할당의 경우 새로운 메모리 공간에 값을 할당하고 변수의 메모리 주소를 바꿔주는 방식으로 작동한다.  
버려진 메모리공간은 `가비지 컬렉터`에 의해서 관리 된다.  

실질적인 재할당이 되지 않는 상수를 선언하기 위해서는 `const`를 사용한다.

## 식별자 네이밍 규칙

식별자 네이밍 규칙은 다음과 같다.
- 식별자는 특수문자를 제외한 문자, 숫자, 언더바(_), 달러($)를 포함 할 수 있다.
- 숫자로 시작할 수 없다.
- 예약어는 사용 불가능 하다.
- 대소문자를 구별한다.

<br><br>

# 표현식과 문

값(value)은 표현식(expression)이 평가(evaluate)되어 생성된 결과  

## 리터럴(Literal)

값을 이할 수 있는 무낮 또는 약속된 기호를 사용해 값을 생성하는 표기법

| 리터럴      | 예시                            | 비고      |
| ----------- | ------------------------------- | --------- |
| 정수        | 100                             |           |
| 부동 소수점 | 10.5                            |           |
| 2진수       | 0b01000001                      | 0b로 시작 |
| 8진수       | 0o101                           | 0o로 시작 |
| 16진수      | 0x41                            | 0x로 시작 |
| 문자열      | "Hello", "World"                |           |
| 불리언      | true, false                     |           |
| null        | null                            |           |
| undefined   | undefined                       |           |
| 객체        | {name: "kim", address: "Seoul"} |           |
| 배열        | [1, 2, 3]                       |           |
| 함수        | function() {}                   |           |
| 정규 표현식 | [A-Z]+/g                        |           |

## 표현식(Expression)

표현식은 값으로 평가될 수 있는 statement다.  
또한 Value로 Evaluate될 수 있는 statement는 표현식

## 문(Statement)

Javascript에서는 세미콜론을 자동 삽입해주는 기능이 있다.(Automatic semicolon insertion)   
세미콜론을 붙이는 것이 ESLint등의 정적 분석도구에서도 사용하며, 권장되는 방식이다.

<br><br>

# 데이터 타입

ES6에서는 6개의 원시 데이터 타입(primitive type)과 객체 타입으로 분류한다.
| 구분      | 데이터타입      | 설명                                                |
| --------- | --------------- | --------------------------------------------------- |
| 원시타입  | 숫자(Number)    | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
|           | 문자열(String)  | 문자열                                              |
|           | 불리언(Boolean) | true, false                                         |
|           | undefined       | var 변수에 암묵적으로 할당                          |
|           | null            | 값이 없는 것을 의도적으로 명시                      |
|           | 심볼(Symbol)    | ES6 에서 추가된 7번째 타입                          |
| 객체 타입 |                 | 객체, 함수, 배열                                    |

## Number

타 언어에 다양한 숫자 타입(int, float, double...)이 존재하는 것에 비해 자바스크립트는 단 하나의 숫자 타입만 존재  
Number 타입은 배정밀도 64비트 부동소수점 형식을 따른다.  
모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입(integer type)이 별도로 존재하지 않는다.  

Number 타입은 추가적으로 세 가지 특별한 값도 표현할 수 있다.
- Infinity : 양의 무한대
- -Infinity : 음의 무한대
- NaN : 산술 연산 불가(not-a-number)

## String

텍스트 데이터를 나타내는데 사용  
문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.  
```js
// 세가지 방식으로 텍스트를 감싼다. 일반적으로 '' 사용
var string;
string = '';
string = "";
string = ``;
```

## Template

`를 사용한 리터럴로, 멀티라인(multi-line), 표현식 삽입(expression-interpolation), 태그드(tagged) 템플릿 등 편리한 문자열 처리를 제공  
```js
var template;

//multi-line
template = 'Hello\nWorld';
template = `Hello
World`;

//expression-interpolation
var first = 'hello';
var last = 'world'
template = 'My Name is ' + first + ' ' + last; //'My Name is hello world'
template = `My Name is ${first} ${last}`; // 'My Name is hello world'

template = `1 + 2 = ${1+2}` // '1 + 2 = 3'
```

## Boolean

참, 거짓을 나누는 `true`, `false`를 가짐

## undefined

다른 언어에서는 할당되지 않는 값은 쓰레기 값으로 초기화 되는 것에 비해, javascript에서는 var 변수 선언에 의해 암묵적으로 할당된다.  

## null

위에서 만약 값이 없음을 명시적으로 알리고 싶을 때는 null을 사용한다

## Symbol

변경 불가능한 원시 타입의 값  
다른 값과 중복되지 않는 유일무이한 값  
주로 이름이 충돌할 일이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용  

`Symbol` 함수를 호출해 생성. 이때 생성된 Symbol값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일한 값이다.

## 필요성

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

## 동적 타이핑

정적 타입언어 : C, Java등
- 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다.
- 명시적 타입 선언
- 변수의 타입 변경 불가능하며, 선언한 타입에 맞는 값만 할당할 수 있다.
- 컴파일 시점에 타입 체크

동적 타입언어 : python, javascript
- 키워드를 통해서 변수를 선언
- 어떠한 데이터 값이라도 자유롭게 할당 가능
- typeof등의 연산자로 타입 조사
- 값을 **할당하는 시점에 변수의 타입이 동적으로 결정** 되며 자유롭게 변경
- 유연성은 높지만 신뢰성은 떨어진다.

변수를 사용할 때 유의사항
- 변수는 꼭 필요한 경우에 한해 제한적으로 사용.
- 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.
- 전역변수는 최대한 사용하지 않도록 한다.
- 변수보다는 상수를 사용해 값의 변경을 억제한다.
- 변수 이름은 변수의 목적이나 의미를 파악할 수 있는 네이밍을 한다.

<br><br>

# 연산자

연산자 : 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.  
피연산자 : 연산자의 대상, 값으로 평가될 수 있는 표현식  

## 산술 연산자

피연산자를 대상으로 수학적 계산을 수행. 산술연산이 불가능한 경우 NaN을 반환  

- 이항 산술 연산자
| 이항 산술 연산자 | 의미   | 부수효과 | 예시 |
| ---------------- | ------ | -------- | ---- |
| +                | 덧셈   | X        | 1+2  |
| -                | 뺄셈   | X        | 2-1  |
| *                | 곱셈   | X        | 1*2  |
| /                | 나눗셈 | X        | 5/2  |
| %                | 나머지 | X        | 5%2  |

- 단항 산술 연산자
| 단항 산술 연산자 | 의미                                          | 부수효과 | 예시             |
| ---------------- | --------------------------------------------- | -------- | ---------------- |
| ++               | 증가                                          | O        | score++, ++score |
| --               | 감소                                          | O        | score--, --score |
| +                | 어떠한 효과도 없음                            | X        | +10              |
| +                | 양수를 음수로, 음수를 양수로 반전한 값을 반환 | X        | -(-10)           |

다른 언어와 같이 `++`, `--`의 경우 위치에 따라서 연산 순서가 달라진다.
- 피연산자 앞에 위치 : 먼저 피연산자의 값을 증가/감소 시킨 후 다른 연산을 수행
- 피연산자 뒤에 위치 : 다른 연산을 먼저 수행한 뒤 피연산자의 값을 증가/감소

`+`의 경우 피연산자 중 하나 이상이 문자열인 경우 문자열 연결로 자동 연산  
`true`, `false`, `null`, `undefined`의 경우도 자동 치환하여 계산한다.
- 이를 암묵저거 타입변환(implicit coercion) 또는 타입 강제변환(type coercion)이라고 한다.

```js
1 + '2'; // 12
1 + 2; //3
1 + true; //2
1 + false; //1
1 + null; //1
1 + undefined; // NaN
```

## 할당 연산자

- 우항에 있는 결과를 좌항에 있는 변수에 할당
| 할당 연산자 | 예     | 동일 표현 | 부수 효과 |
| ----------- | ------ | --------- | --------- |
| =           | x=5    | x=5       | O         |
| +=          | x += 5 | x = x + 5 | O         |
| -=          | x -= 5 | x = x - 5 | O         |
| *=          | x *= 5 | x = x * 5 | O         |
| /=          | x /= 5 | x = x / 5 | O         |
| %=          | x %= 5 | x = x % 5 | O         |

할당문 그 자체는 할당된 값으로 연산된다.

```js
var a, b, c;
a = b = c = 0;
// c = 0 : 0으로 치환
// b = 0 : 0으로 치환
// a = 0 : 0으로 치환
```
## 비교 연산자

조건식에서 주로 사용한다.

- 동등/일치 비교연산자
| 비교 연산자 | 의미        | 사례  | 설명                     | 부수효과 |
| ----------- | ----------- | ----- | ------------------------ | -------- |
| ==          | 동등 비교   | x==y  | x와 y의 값이 같음        | x        |
| ===         | 일치 비교   | x===y | x와 y의 값과 타입이 같음 | x        |
| !=          | 부동등 비교 | x!=y  | x와 y의 값이 다름        | x        |
| !==         | 부일치 비교 | x!==y | x와 y의 값과 타입이 다름 | x        |

`==`와 `===`의 경우 같은지 여부하는 연산자지만 그 엄경도가 다르다.  
동등비교(==)의 경우 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.  
일치비교(===)의 경우 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 `true`를 반환한다.  

동등비교의 경우 결과를 예측하기 어렵고, 십수하기 쉽기 때문에 사용하지 않는 편이 좋다.  
일치비교의 경우 NaN의 경우를 제외하면 타 언어의 동등 연산자와 같은 역할을 한다.

```js
Nan === Nan // false
```

위 문제점을 해결한 Object.is() 메서드가 ES6에서 도입되었다.

```js
Obejct.is(+0, -0) // false
Obejct.is(NaN, NaN) // true
```

## 대소 관계 비교 연산자
| 대소 관계 비교 연산자 | 예제   | 설명                   | 부수 효과 |
| --------------------- | ------ | ---------------------- | --------- |
| >                     | x > y  | x가 y 보다 크다        | X         |
| <                     | x > y  | x가 y 보다 작다        | X         |
| >=                    | x >= y | x가 y 보다 크거나 같다 | X         |
| >=                    | x >= y | x가 y 보다 작거나 같다 | X         |

## 삼항 조건 연산자

조건식을 간단한 연산자를 통해 처리하는 방식이다.

> `조건식 ? true일 때 반환 값 : false일 때 반환 값`

```js
var result = score >= 60 ? 'pass' : 'fail';
``` 

<br><br>

# 제어문


<br><br>

# 타입 변환과 단축평가


